# 监控首屏结束时间



## **什么是白屏和首屏时间**

### **白屏时间(FP)**

白屏时间(First Paint)：是指浏览器从响应用户输入网址地址，到浏览器开始显示内容的时间。

白屏时间节点指的是从用户进入网站（输入url、刷新、跳转等方式）的时刻开始计算，一直到页面有内容展示出来的时间节点。

这个过程包括dns查询、建立tcp连接、发送首个http请求（如果使用https还要介入TLS的验证时间）、返回html文档、html文档head解析完毕。

在html文档的head中所有的静态资源以及内嵌脚本/样式之前记录一个时间点，在head最底部记录另一个时间点，两者的差值作为白屏时间

```
复制代码<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>白屏时间</title>
    <script>
        // 开始时间
        window.pageStartTime = Date.now();
    </script>
    <link rel="stylesheet" href="">
    <link rel="stylesheet" href="">
    <script>
        // 白屏结束时间
        window.firstPaint = Date.now()
    </script>
</head>
<body>
    <div>123</div>
</body>
</html>

白屏时间 = firstPaint - pageStartTime //页面开始展示的时间点 - 开始请求的时间点
```

**缺点：**

无法获取解析html文档之前的时间信息

### **首屏时间(FCP)**

首屏时间(First Contentful Paint)：是指浏览器从响应用户输入网络地址，到首屏内容渲染完成的时间。



###  

### 手动采集

> **FMP**（First Meaningful Paint）是指页面的主要内容出现在屏幕上所需的时间。

一般是通过埋点的方式进行， 比如在页面开始位置打上 `FMP.Start()`，在首屏结束位置打上 `FMP.End()`，利用 `FMP.End() - FMP.Start()` 获取到首屏时间。

优点：

- 兼容性强，可以随情况变动。
- 去中心化，各个业务负责自己的埋点代码。

缺点：

- 埋点代码会和业务代码严重耦合
- 业务较多时，可能覆盖率不足







## 使用 Performance API

[Performance](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FPerformance) 接口可以获取到当前页面中与性能相关的信息。它是 High Resolution Time API 的一部分，同时也融合了 Performance Timeline API、Navigation Timing API、 User Timing API 和 Resource Timing API。

`PerformanceTiming` 接口是为保持向后兼容性而保留的传统接口，提供了在加载和使用当前页面期间发生的各种事件的**性能计时信息**。



### performance都有哪些属性：

- ```
  - memory：显示此刻内存占用情况，是一个动态值
    - usedJSHeapSize：JS对象占用的内存数
    - jsHeapSizeLimit：可使用的内存
    - totalJSHeapSize：内存大小限制
  
  正常usedJSHeapSize不大于totalJSHeapSize，如果大于，说明可能出现了内存泄漏。
  
  - navigation：显示页面的来源信息
    - redirectCount：表示如果有重定向的话，页面通过几次重定向跳转而来，默认为0
    - type：表示页面打开的方式。0-正常进入；1-通过window.reload()刷新的页面；2-通过浏览器的前进后退按钮进入的页面；255-非以上方式进入的页面。
  - onresourcetimingbufferfull：在resourcetimingbufferfull事件触发时会被调用的一个event handler。它的值是一个手动设置的回调函数，这个回调函数会在浏览器的资源时间性能缓冲区满时执行。
  - timeOrigin：一系列时间点的基准点，精确到万分之一毫秒。
  - timing：一系列关键时间点，包含网络、解析等一系列的时间数据。
  ```

  



### **timing中的时间点**

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/14/16f0217ac454ae7b~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp)

- ```
  - navigationStart：同一个浏览器上一个页面卸载(unload)结束时的时间戳。如果没有上一个页面，这个值会和fetchStart相同
  - unloadEventStart: 上一个页面unload事件抛出时的时间戳。如果没有上一个页面，这个值会返回0。
  - unloadEventEnd: 和 unloadEventStart 相对应，unload事件处理完成时的时间戳。如果没有上一个页面,这个值会返回0。
  - redirectStart: 第一个HTTP重定向开始时的时间戳。如果没有重定向，或者重定向中的一个不同源，这个值会返回0
  - redirectEnd: 最后一个HTTP重定向完成时（也就是说是HTTP响应的最后一个比特直接被收到的时间）的时间戳。如果没有重定向，或者重定向中的一个不同源，这个值会返回0
  - fetchStart: 浏览器准备好使用HTTP请求来获取(fetch)文档的时间戳。这个时间点会在检查任何应用缓存之前。
  - domainLookupStart: DNS 域名查询开始的UNIX时间戳。如果使用了持续连接(persistent connection)，或者这个信息存储到了缓存或者本地资源上，这个值将和fetchStart一致。
  - domainLookupEnd: DNS 域名查询完成的时间。如果使用了本地缓存（即无 DNS 查询）或持久连接，则与 fetchStart 值相等
  - connectStart: HTTP（TCP） 域名查询结束的时间戳。如果使用了持续连接(persistent connection)，或者这个信息存储到了缓存或者本地资源上，这个值将和 fetchStart一致。
  - connectEnd: HTTP（TCP） 返回浏览器与服务器之间的连接建立时的时间戳。如果建立的是持久连接，则返回值等同于fetchStart属性的值。连接建立指的是所有握手和认证过程全部结束。
  - secureConnectionStart: HTTPS 返回浏览器与服务器开始安全链接的握手时的时间戳。如果当前网页不要求安全连接，则返回0。
  - requestStart: 返回浏览器向服务器发出HTTP请求时（或开始读取本地缓存时）的时间戳。
  - responseStart: 返回浏览器从服务器收到（或从本地缓存读取）第一个字节时的时间戳。如果传输层在开始请求之后失败并且连接被重开，该属性将会被数制成新的请求的相对应的发起时间。
  - responseEnd: 返回浏览器从服务器收到（或从本地缓存读取，或从本地资源读取）最后一个字节时。（如果在此之前HTTP连接已经关闭，则返回关闭时）的时间戳。
  - domLoading: 当前网页DOM结构开始解析时（即Document.readyState属性变为“loading”、相应的 readystatechange事件触发时）的时间戳。
  - domInteractive: 当前网页DOM结构结束解析、开始加载内嵌资源时（即Document.readyState属性变为“interactive”、相应的readystatechange事件触发时）的时间戳。
  - domContentLoadedEventStart: 当解析器发送DOMContentLoaded 事件，即所有需要被执行的脚本已经被解析时的时间戳。
  - domContentLoadedEventEnd: 当所有需要立即执行的脚本已经被执行（不论执行顺序）时的时间戳。
  - domComplete: 当前文档解析完成，即Document.readyState 变为 'complete'且相对应的readystatechange 被触发时的时间戳
  - loadEventStart: load事件被发送时的时间戳。如果这个事件还未被发送，它的值将会是0。
  - loadEventEnd: 当load事件结束，即加载事件完成时的时间戳。如果这个事件还未被发送，或者尚未完成，它的值将会是0
  ```

  

能计算到哪些时间：

- ```
  - 重定向耗时：redirectEnd - redirectStart
  - DNS查询耗时：domainLookupEnd - domainLookupStart
  - TCP链接耗时：connectEnd - connectStart
  - HTTP请求耗时：responseEnd - responseStart
  - 解析dom树耗时：domComplete - domInteractive
  - 白屏时间：responseStart - navigationStart
  - DOM ready时间：domContentLoadedEventEnd - navigationStart
  - onload时间：loadEventEnd - navigationStart
  
  
  ```

  

`window.performance.timing` 

![EB5EB996-31B6-4c7c-A6C7-946FC2B529D0.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7c0fd1db7d474675808604c4c4673662~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)



### **资源性能API**

performance.timing记录的是用于分析页面整体性能指标。如果要获取个别资源（例如JS、图片）的性能指标，就需要使用Resource Timing API。

performance.getEntries()方法，包含了所有静态资源的数组列表；每一项是一个请求的相关参数有name，type，时间等等。

除了performance.getEntries之外，performance还包含一系列有用的方法，比如：

- performance.now()
- Performance.getEntriesByName()



## **我该计算首屏时间还是白屏时间？**

在评估页面是否开始渲染方面，首屏时间会比白屏时间更精确，但是二者的结束时间往往很接近。所以要根据自己的业务场景去决定到底该用哪种计算方式。

对于交互性比较少的简单网页，由于加载比较快，所以二者区别不大，因此，可以根据喜好任选一种计算方式。

对于大型的复杂页面，你会发现由于需要处理更多复杂的元素，白屏时间和首屏时间相隔比较远，这时候，计算首屏时间会更有用。

## **白屏和首屏的优化**

目前白屏常见的优化方案有：

- SSR
- 预渲染
- 骨架屏

优化首屏加载时间的方法：

- CDN分发（减少传输距离）
- 后端在业务层的缓存
- 静态文件缓存方案
- 前端的资源动态加载
- 减少请求的数量
- 利用好HTTP压缩





## 服务端模板类型指标采集 SSR

## 监听 DOMContentLoaded 事件

```js
document.addEventListener('DOMContentLoaded', () => {
  const firstScreenEndTime = Date.now();
  
  // 记录首屏结束时间  
});
```



## 单页面类型指标采集

单页面的首屏时间和 SSR 的首屏时间有什么不同吗？

随着 Vue 和 React 等前端框架盛行，Performance 已无法准确的监控到页面的首屏时间。因为 `DOMContentLoaded` 的值只能表示**空白页**（当前页面 body 标签里面没有内容）加载花费的时间。浏览器需要先加载 JS , 然后再通过 JS 来渲染页面内容，这个时候**单页面类型**首屏才算渲染完成。

那我们使用什么数据来当做首屏时间呢？

如果在首屏渲染过程中，记录各个资源的加载时间，那么最后某个资源加载完的时间是不是就是首屏时间呢？`MutationObserver` 就可以做这件事情。

> [MutationObserver](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FMutationObserver) 接口提供了监视对 DOM 树所做更改的能力。它被设计为旧的 Mutation Events 功能的替代品，该功能是 DOM3 Events 规范的一部分。

```
initObserver() {
  try {
    if (this.supportTiming()) {
      this.observer = new MutationObserver(() => {
        let time = Date.now() - performance.timing.fetchStart;
        let bodyTarget = document.body;
        if (bodyTarget) {
          let score = 0;
          score += calculateScore(bodyTarget, 1, false);
          SCORE_ITEMS.push({
            score,
            t: time
          });
        } else {
          SCORE_ITEMS.push({
            score: 0,
            t: time
          });
        }
      });
    }

    this.observer.observe(document, {
      childList: true,
      subtree: true
    });

    if (document.readyState === "complete") {
      this.mark = 'readyState';
      this.calFinallScore();
    } else {
      window.addEventListener(
        "load",
        () => {
          this.mark = 'load';
          this.calFinallScore();
        },
        true
      );
      window.addEventListener(
        'beforeunload',
        () => {
          this.mark = 'beforeunload';
          this.calFinallScore();
        },
        true
      )
      const that = this;
      function listenTouchstart() {
        if(Date.now() > 2000) {
          that.calFinallScore();
          this.mark = 'touch';
          window.removeEventListener('touchstart', listenTouchstart, true);
        }
      }
      window.addEventListener(
        'touchstart',
        listenTouchstart,
        true
      )
    }
  } catch (error) {}
}


```





我们通过 `MutationObserver` 来监听 Dom 的变化, 然后计算当前时刻 Dom 的分数。

### 5.2 计算分数

```js
js复制代码function calculateScore(el, tiers, parentScore) {
  try {
    let score = 0;
    const tagName = el.tagName;
    if ("SCRIPT" !== tagName && "STYLE" !== tagName && "META" !== tagName && "HEAD" !== tagName) {
      const childrenLen = el.children ? el.children.length : 0;
      if (childrenLen > 0) for (let childs = el.children, len = childrenLen - 1; len >= 0; len--) {
        score += calculateScore(childs[len], tiers + 1, score > 0);
      }
      if (score <= 0 && !parentScore) {
        if (!(el.getBoundingClientRect && el.getBoundingClientRect().top < WH)) return 0;
      }
      score += 1 + .5 * tiers;
    }
    return score;
  } catch (error) {

  }
}
```

计算分数主要做这几件事情：

- 从 body 元素开始递归计算。
- 排查无用的元素标签。
- 如果元素超出屏幕就认为是 0 分。
- 第一层的元素是 1 分，第二次的元素是 1 + (层数 * 0.5)，也就是 1.5 分，依次类推，最终得打整个 Dom 数的总体分数。

###  计算出 FMP

我们通过 `MutationObserver` 得到了一个数组，数组的每一项就是每次 Dom 变化的时间和分数。

```js
js复制代码let fmps = getFmp(SCORE_ITEMS);
let record = null
for (let o = 1; o < fmps.length; o++) {
  if (fmps[o].t >= fmps[o - 1].t) {
    let l = fmps[o].score - fmps[o - 1].score;
    (!record || record.rate <= l) && (record = {
      t: fmps[o].t,
      rate: l
    });
  }
}
```

通过上面的代码，我们会得到最终的 `FMP` 的值，就是变化最大的这个 DOM 变化。此时 `FMP` 值就是 `SPA` 项目的首屏时间。









## 监听 load 事件

```js
window.addEventListener('load', () => {
  const firstScreenEndTime = Date.now();

  // 记录首屏结束时间
});
```

## 检测特定元素加载状态

```js
const targetElement = document.getElementById('main-content');

function checkElementReady() {
  if (targetElement.offsetParent) {
    const firstScreenEndTime = Date.now();

    // 记录首屏结束时间
    
    window.removeEventListener('scroll', checkElementReady);
  }
}

window.addEventListener('scroll', checkElementReady);


```
记录获取到的首屏结束时间,可以通过 AJAX 上传到后端或者本地存储,用于监控和优化首屏体验。









